## Comments

- Бывают случаи, когда приходится работать с необычными сценариями, в которых отсутствуют общепринятые соглашения. Комментирование такого кода, объясняющее, что он делает и в каком контексте рассматривается, поможет другим программистам, а также послужит напоминанием для тебя, когда вернетешься к нему в будущем
- Все тегированные комментарии должны быть оформлены строчными комментариями, а если требуется подробное описание, то ниже новый многострочный комментарий
- Если в задаче требуется **временно** скрыть кусок приложения, то эта часть оборачивается соответствующими правила для каждого из блоков файла и выше ставится тег `HACK`, номер задачи и причину (чтобы иметь основания о проделанной работе, при возникновении вопросов от менеджера/заказчика, мол это не мы придумали и не наша ошибка). Например:
```html
<!-- HACK(CH-3322): Скрыт по инициативе дизайнера (и настойчиво рекомендуется оставить комментарий в задаче) -->
<!-- <div /> -->
```

```scss
// HACK(CH-3322): Скрыт по инициативе дизайнера (и настойчиво рекомендуется оставить комментарий в задаче)
// display: flex;
```

- Если нужно времено отложить разработку в текущем месте приложения и чтобы не забыть доработать, условимся помечать такие места двумя способами `FIXME: description`, `DEBT: description` или `TODO: description`.
- `FIXME:` - маркируется то место в коде, которое необходимо закончить в рамках текущей задачи, и если в пришедшем МР есть хотя бы один такой комментарий, моментально возвращать задачу на доработку.
- `TODO:` - маркируется то место в коде, которое планируется выполнить в другой задаче.
- `API:` - маркируется то место в коде, где задумано добавить код интеграции в другой задаче.
- `DEBT:` - маркируется то место в коде, которое отправляется в технический долг.
- `description`: краткое описание, но передающее основной смысл. Писать так, чтобы другой человек понял ваш комментарий. Не приветствуются комментарии следующего содержания `не забыть поправить` или `Петя сказал, что поправит это своим МР` (не указана цель правки). Например:
- Когда нужно обозначить какой то огромный блок, который указанием обычного комментария будет неочевидно, что это относится к куску кода а не строчке, и при этом он должен работать, предлагается оборачивать соответствующим тегом `START` & `END`. (Пример ниже)

```html
<!-- TODO: Здесь запланировано место для шапки -->
```

```ts
// DEBT | START: Сделать утилиту и перенести все зависимости туда
const DISCOUNTS_OBJECT = {
  promo: 10,
  newYear: 7,
  blackFriday: 25
} as const

const DISCOUNTS_ARRAY = ['first', 'seconds'] as const

type DiscountsEventType = keyof typeof DISCOUNTS_OBJECT // "promo | newYear | blackFriday"

type DiscountsValueType = typeof DISCOUNTS_OBJECT[DiscountsEventType] // "10 | 7 | 25", если бы не было "as const", то было бы "number"

type DiscountsType = typeof DISCOUNTS_ARRAY[number] // "first | seconds", вместо "string[]"
// DEBT | END: Сделать утилиту и перенести все зависимости туда

// API: Заменить фейковый запрос

// FIXME: При загрузке приложение падает, спросить SOMEBODY чтобы помог

// DEBT: Решить проблему с дублированием кода
/**
 * Здесь можно продолжить описание технического долга...
 */
```

```scss
// FIXME: разобраться почему стили не применяются в сафари
// display: flex;
```

## Git

1. Репозиторий должен быть настроен так, чтобы МР было невозможно подтвердить, пока не решены все замечания по МР или пайплайн завершился с ошибками
   - `settings` -> `general` -> `Merge requests` -> `Pipelines must succeed` (при наличи настроек gitlab-ci на проекте)
   - `settings` -> `general` -> `Merge requests` -> `All discussions must be resolved`
1. Гит репозиторий должен иметь три обязаельные ветки `main`/`master`, `dev`/`develop` и `release`
1. Ветке `main`/`master` - присваивается модификатор `protected` доставка кода в которую осуществляется **только** через мерж реквест
1. Ветке `release` - присваивается модификатор `protected` доставка кода в которую осуществляется **только** через мерж реквест из `main`/`master`
1. Ветке `dev`/`develop` - присваивается модификатор `protected` доставка кода в которую осуществляется как через мерж реквест, так и напрямую `project member` с правами `maintainer` и выше (для того чтобы при прямом МР в `main`/`master`, когда нужно выкатить хотфикс, в обход готовящемуся релизу, после, подтянуть изменения из `main`/`master` и запушить их в `dev`/`develop`)
1. **Любая** задача решается в своей отдельной ветке

### Ветки и коммиты

- Название ветки формируется из `TASK-ID`, где `TASK-ID` - Id задачи в Jira, без каких либо вложенностей (такие как: `feat/CP-1111` не приветствуются, просто `CP-1111`)
- В случае когда нужно нескольким разработчикам работать над одной большой задачей одновременно:
  1. Попросить ТимЛида или Менеджера разбить на более мелкие задачи с указанием иерархии и зависимости (какая какую блокирует через инструмент линкования в джире)
  1. Создать ветку с основным `TASK-ID` и запушить
- Ответвиться от ветки `TASK-ID` добавив модификатор с никнеймом разработчика, например: `CP-2023-saitama`
- По завершению выполнения сделать МР в `TASK-ID`
- По завершению, с окончательным результатом, сделать МР в `dev`/`develop`

### Merge requests

Merge request формируется, следующим образом `Draft: TYPE(SCOPE): TITLE`, где:

- `Draft` - опциональный модификатор, указывающий что МР не готов к проверке ревьюером.
- `TYPE` - модификатор указывающий вид проводимых работ (в какой раздел попадает в CHANGELOG.md):
  - **feat**：Новые фичи
  - **fix**：bugfix
  - **docs**：Обновление документации
  - **style**：Модификации кода, не влияющие на логику программы (изменение пробельных символов, форматирование отступов, заполнение отсутствующих точек с запятой и т. д. без изменения логики кода)
  - **refactor**：Рефакторинг кода (ни новых функций, ни исправлений ошибок)
  - **perf**：Производительность, оптимизация
  - **test**：Добавление новых тестов или обновление существующих
  - **build**：Основная цель - изменить фиксацию системы сборки проекта (например, глюк, новый веб-пакет, конфигурация накопительного пакета и т.д.).
  - **ci**：Основная цель - изменить коммиты, в которых проект продолжает процесс интеграции (например, Travis, Jenkins, GitLab CI, Circle и т. д.).
  - **chore**：Другие типы, не принадлежащие к указанным выше типам
  - **revert**：Откатить предыдущий коммит
- `SCOPE` - один из вариантов:
  - `TASK-ID` - Id задачи в Jira, например: `DC-3205`
  - **no-release** - помечает коммит, который не триггерит поднятие версии проекта
- `TITLE` - один из вариантов:
  - `TASK-TITLE` - полное название задачи в Jira (заголовок)
  - Краткое описание изменений, если коммит не связан с задачей

#### Требования к PR

> **Важно!** Если случилось так, что код достался без обработки линтера и преттира. В таком случае вынести форматирование в отдельный МР, не смешивая с кодом основной задачи, с пометкой **style:**. В противном случае, МР будет отклонён и отправлен на исправление

- Заголовок должен кратко изложить суть данного изменения/нововведения.
- MR должен иметь код только по задаче указанной в теме.
- Каждый свой МР разработчик **обязан** сам:
  1. Просмотреть на наличие недочетов в коде, опираясь на текущий контрибутинг.
  1. Проанализировать на предмет улучшения кодовой базы.
     - Если есть код который можно оптимизировать, правки задевают другие файлы несвязанные с задачей, и сам процесс займёт не более 30 минут, то сделать ответвление от ветки задачи, внести правки и сделать отдельный МР в ветку задачи
     - Определить эстетичные решения и предложить наставнику вынести их в библиотеку сниппетов, для последующего переиспользования в других проектах. После согласования пометить кусок код `TODO:` комментарием, с описание того что нужно сделать (см. правилами [комментирования](CONTRIBUTING.md#comments))
     - Всё не в ходящее в выше перечисленное необходимо пометить `DEBT:` комментарием, с описание того что нужно сделать (см. правилами [комментирования](CONTRIBUTING.md#comments)), и попросить наставника/менеджера добавить задачу в эпик технического долга

### Пример PR
  ### Commit
  - git add .
  - git commit -m 'CNF-1 | Реализована логика SInput'
  - git push

  ### PR
  - Название задачи CNF-1: Реализовать компонент SInput
  - Название PR: feat(CNF-1): Реализовать компонент SInput
  - Краткое описание задачи: Реализовал логику видимости пароля при нажатии на иконку глазика
  - Подпись: Closes #<номер_ишки>
  - Асайн на себя
  - Ревьюер на того, кто будет проводить ревью
